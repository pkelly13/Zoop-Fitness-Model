barplot(-day.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='white',xaxt='n',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)))
barplot(night.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='black',xlim=c(-max(day.datei$Counts,na.rm=T),max(day.datei$Counts,na.rm=T)),xaxt='n',main=lakes[i])
barplot(-day.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='white',xaxt='n',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)))#
par(new=T)#
night.datei=night[night$Sample.date==night.dates[length(night.dates)],]#
night.datei=night.datei[order(night.datei$Depth.Top..m.,decreasing=T),]#
barplot(night.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='black',xlim=c(-max(day.datei$Counts,na.rm=T),max(day.datei$Counts,na.rm=T)),xaxt='n',main=lakes[i])#
axis(1,labels=F)#
abline(v=0)
max(day.datei$Counts,na.rm=T)
barplot(-day.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='white',xaxt='n',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)))#
par(new=T)#
night.datei=night[night$Sample.date==night.dates[length(night.dates)],]#
night.datei=night.datei[order(night.datei$Depth.Top..m.,decreasing=T),]#
barplot(night.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='black',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)),xaxt='n',main=lakes[i])#
axis(1,labels=F)#
abline(v=0)
setwd('~/Documents/Notre Dame/ASLO 2014/DVM barplots')#
for(i in 1:length(lakes)){#
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)#
#
pdf(file=paste('DaphniaDVM',lakes[i],'.pdf',sep=''),height=8.5,width=11)#
day.datei=day[day$Sample.date==day.dates[length(day.dates)],]#
day.datei=day.datei[order(day.datei$Depth.Top..m.,decreasing=T),]#
barplot(-day.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='white',xaxt='n',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)))#
par(new=T)#
night.datei=night[night$Sample.date==night.dates[length(night.dates)],]#
night.datei=night.datei[order(night.datei$Depth.Top..m.,decreasing=T),]#
barplot(night.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='black',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)),xaxt='n',main=lakes[i])#
axis(1,labels=F)#
abline(v=0)#
dev.off()#
}#
#
#Barplots that show off DHM across lakes#
for(i in 1:length(lakes)){#
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)#
#
pdf(file=paste('DHM_Daphnia',lakes[i],'.pdf',sep=''),height=8.5,width=11)#
day.datei=day[day$Sample.date==day.dates[length(day.dates)],]#
day.datei=day.datei[order(day.datei$Depth.Top..m.,decreasing=T),]#
barplot(-day.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='white',xaxt='n',xlim=c(-max(c(day.datei$Counts,night.datei$Counts),na.rm=T),max(c(day.datei$Counts,night.datei$Counts),na.rm=T)))#
par(new=T)#
night.datei=night[night$Sample.date==night.dates[length(night.dates)],]#
night.datei=night.datei[order(night.datei$Depth.Top..m.,decreasing=T),]#
barplot(night.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='black',xlim=c(-max(c(day.datei$Counts,night.datei$Counts),na.rm=T),max(c(day.datei$Counts,night.datei$Counts),na.rm=T)),xaxt='n',main=lakes[i])#
axis(1,labels=F)#
abline(v=0)#
dev.off()#
}
i=1
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)
lakei
day.datei=day[day$Sample.date==day.dates[length(day.dates)],]#
day.datei=day.datei[order(day.datei$Depth.Top..m.,decreasing=T),]#
barplot(-day.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='white',xaxt='n',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)))
par(new=T)#
night.datei=night[night$Sample.date==night.dates[length(night.dates)],]#
night.datei=night.datei[order(night.datei$Depth.Top..m.,decreasing=T),]#
barplot(night.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='black',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)),xaxt='n',main=lakes[i])#
axis(1,labels=F)#
abline(v=0)
barplot(-day.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='white',xaxt='n',xlim=c(-max(day.datei$Counts,na.rm=T),max(day.datei$Counts,na.rm=T)))#
par(new=T)#
night.datei=night[night$Sample.date==night.dates[length(night.dates)],]#
night.datei=night.datei[order(night.datei$Depth.Top..m.,decreasing=T),]#
barplot(night.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='black',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)),xaxt='n',main=lakes[i])#
axis(1,labels=F)#
abline(v=0)
-max(day.datei$Counts,na.rm=T)
max(night.datei$Counts,na.rm=T)
barplot(-day.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='white',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)))
par(new=T)
night.datei=night[night$Sample.date==night.dates[length(night.dates)],]#
night.datei=night.datei[order(night.datei$Depth.Top..m.,decreasing=T),]
barplot(night.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='black',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)),xaxt='n',main=lakes[i])
axis(1,labels=F)
abline(v=0)
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)#
#
pdf(file=paste('DaphniaDVM',lakes[i],'.pdf',sep=''),height=8.5,width=11)#
day.datei=day[day$Sample.date==day.dates[length(day.dates)],]#
day.datei=day.datei[order(day.datei$Depth.Top..m.,decreasing=T),]#
barplot(-day.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='white',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)))#
par(new=T)#
night.datei=night[night$Sample.date==night.dates[length(night.dates)],]#
night.datei=night.datei[order(night.datei$Depth.Top..m.,decreasing=T),]#
barplot(night.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='black',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)),xaxt='n',main=lakes[i])#
axis(1,labels=F)#
abline(v=0)
dev.off()
day.datei=day[day$Sample.date==day.dates[length(day.dates)],]#
day.datei=day.datei[order(day.datei$Depth.Top..m.,decreasing=T),]#
barplot(-day.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='white',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)))#
par(new=T)#
night.datei=night[night$Sample.date==night.dates[length(night.dates)],]#
night.datei=night.datei[order(night.datei$Depth.Top..m.,decreasing=T),]#
barplot(night.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='black',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)),xaxt='n',main=lakes[i])#
axis(1,labels=F)#
abline(v=0)
i=2
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)
day.datei=day[day$Sample.date==day.dates[length(day.dates)],]#
day.datei=day.datei[order(day.datei$Depth.Top..m.,decreasing=T),]#
barplot(-day.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='white',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)))#
par(new=T)#
night.datei=night[night$Sample.date==night.dates[length(night.dates)],]#
night.datei=night.datei[order(night.datei$Depth.Top..m.,decreasing=T),]#
barplot(night.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='black',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)),xaxt='n',main=lakes[i])#
axis(1,labels=F)#
abline(v=0)
barplot(night.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='black',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)),xaxt='n',main=lakes[i])
barplot(night.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='black',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)),main=lakes[i])
max(night.datei$Counts,na.rm=T)
i
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)
night.dates
day.datei=day[day$Sample.date==day.dates[length(day.dates)],]#
day.datei=day.datei[order(day.datei$Depth.Top..m.,decreasing=T),]
day.datei
barplot(-day.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='white',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)))
par(new=T)
night.datei=night[night$Sample.date==night.dates[length(night.dates)],]#
night.datei=night.datei[order(night.datei$Depth.Top..m.,decreasing=T),]#
barplot(night.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',col='black',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)),main=lakes[i])#
axis(1,labels=F)#
abline(v=0)
barplot(-day.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',xaxt='n',col='white',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)))#
par(new=T)#
night.datei=night[night$Sample.date==night.dates[length(night.dates)],]#
night.datei=night.datei[order(night.datei$Depth.Top..m.,decreasing=T),]#
barplot(night.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',xaxt='n',col='black',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)),main=lakes[i])#
axis(1,labels=F)#
abline(v=0)
i=3
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)
day.datei=day[day$Sample.date==day.dates[length(day.dates)],]#
day.datei=day.datei[order(day.datei$Depth.Top..m.,decreasing=T),]#
barplot(-day.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',xaxt='n',col='white',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)))#
par(new=T)#
night.datei=night[night$Sample.date==night.dates[length(night.dates)],]#
night.datei=night.datei[order(night.datei$Depth.Top..m.,decreasing=T),]#
barplot(night.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',xaxt='n',col='black',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)),main=lakes[i])#
axis(1,labels=F)#
abline(v=0)
night.datei$Counts
max(night.datei$Counts,na.rm=T)
setwd('~/Documents/Notre Dame/ASLO 2014/DVM barplots')#
for(i in 1:length(lakes)){#
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)#
#
pdf(file=paste('DaphniaDVM',lakes[i],'.pdf',sep=''),height=8.5,width=11)#
day.datei=day[day$Sample.date==day.dates[length(day.dates)],]#
day.datei=day.datei[order(day.datei$Depth.Top..m.,decreasing=T),]#
night.datei=night[night$Sample.date==night.dates[length(night.dates)],]#
night.datei=night.datei[order(night.datei$Depth.Top..m.,decreasing=T),]#
barplot(-day.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',xaxt='n',col='white',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)))#
par(new=T)#
barplot(night.datei$Counts,horiz=T,ylab='Depth',xlab='Abundance',xaxt='n',col='black',xlim=c(-max(day.datei$Counts,na.rm=T),max(night.datei$Counts,na.rm=T)),main=lakes[i])#
axis(1,labels=F)#
abline(v=0)#
dev.off()#
}
setwd('~/Zoop-Fitness-Model')#
modelParms<-read.csv('fitnessModel_parameters.csv')#
#get rid of unused columns#
modelParms<-modelParms[,-c(1:3)]
BA<-modelParms[modelParms$lakeID=='BA',]
BA
lakes
i=1
lakei=modelParms[modelParms$lakeID==lakes[i],] # use only one lake in lakes vector
lakei
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector
lakei
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]
night.dates=unique(night$Sample.date)
lakej=modelParms[modelParms$lakeID==lakei$Lake.ID[1],]
lakej
lakej.day=lakej[lakej$TOD=='Day' & lakej$dateSample==day.dates[length(day.dates)]]
lakej.day
day.dates[length(day.dates)]
modelParms$dateSample<-format(as.Date(modelParms$dateSample,'%m/%d/%y'),'%m/%d/%y')
head(modelParms)
i=1
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)#
#
lakej=modelParms[modelParms$lakeID==lakei$Lake.ID[1],]#
lakej.day=lakej[lakej$TOD=='Day' & lakej$dateSample==day.dates[length(day.dates)]]
lakej.day
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)#
#
lakej=modelParms[modelParms$lakeID==lakei$Lake.ID[1],]
lakej\
lakej
lakej.day=lakej[lakej$TOD=='Day' & lakej$dateSample==day.dates[length(day.dates)],]
lakej.day
lakej.night=lakej[lakej$TOD=='Night' & lakej$dateSample==day.dates[length(night.dates)],]
lakej.night
modelParms$mu.g<-modelParms$mu/exp(modelParms$growth)
i=1
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)#
#
lakej=modelParms[modelParms$lakeID==lakei$Lake.ID[1],]#
lakej.day=lakej[lakej$TOD=='Day' & lakej$dateSample==day.dates[length(day.dates)],]#
#
lakej.night=lakej[lakej$TOD=='Night' & lakej$dateSample==day.dates[length(night.dates)],]
lakej.night
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML']))
normal
i=1
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)#
#
lakej=modelParms[modelParms$lakeID==lakei$Lake.ID[1],]#
lakej.day=lakej[lakej$TOD=='Day' & lakej$dateSample==day.dates[length(day.dates)],]#
#
lakej.night=lakej[lakej$TOD=='Night' & lakej$dateSample==day.dates[length(night.dates)],]#
#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML']))#
#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo']))#
#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML']))#
#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo']))#
#
x=c(normal,reverse,noDVM,bottom)
x
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}
optimal
y=data.frame(lakeID=lakes[i],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)
y
fitness<-c()#
for(i in 1:length(lakes)){#
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)#
#
lakej=modelParms[modelParms$lakeID==lakei$Lake.ID[1],]#
lakej.day=lakej[lakej$TOD=='Day' & lakej$dateSample==day.dates[length(day.dates)],]#
#
lakej.night=lakej[lakej$TOD=='Night' & lakej$dateSample==day.dates[length(night.dates)],]#
#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML']))#
#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo']))#
#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML']))#
#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo']))#
#
x=c(normal,reverse,noDVM,bottom)#
#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[i],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
fitness=rbind(fitness,y)#
}
fitness<-c()#
for(i in 1:2){#
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)#
#
lakej=modelParms[modelParms$lakeID==lakei$Lake.ID[1],]#
lakej.day=lakej[lakej$TOD=='Day' & lakej$dateSample==day.dates[length(day.dates)],]#
#
lakej.night=lakej[lakej$TOD=='Night' & lakej$dateSample==day.dates[length(night.dates)],]#
#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML']))#
#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo']))#
#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML']))#
#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo']))#
#
x=c(normal,reverse,noDVM,bottom)#
#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[i],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
fitness=rbind(fitness,y)#
}
fitness<-c()#
for(i in 1:1){#
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)#
#
lakej=modelParms[modelParms$lakeID==lakei$Lake.ID[1],]#
lakej.day=lakej[lakej$TOD=='Day' & lakej$dateSample==day.dates[length(day.dates)],]#
#
lakej.night=lakej[lakej$TOD=='Night' & lakej$dateSample==day.dates[length(night.dates)],]#
#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML']))#
#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo']))#
#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML']))#
#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo']))#
#
x=c(normal,reverse,noDVM,bottom)#
#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[i],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
fitness=rbind(fitness,y)#
}
=2
i=2
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)#
#
lakej=modelParms[modelParms$lakeID==lakei$Lake.ID[1],]#
lakej.day=lakej[lakej$TOD=='Day' & lakej$dateSample==day.dates[length(day.dates)],]#
#
lakej.night=lakej[lakej$TOD=='Night' & lakej$dateSample==day.dates[length(night.dates)],]
lakej.night
lakej
lakej.day
night
night.dates
fitness<-c()#
for(i in 1:1){#
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)#
#
lakej=modelParms[modelParms$lakeID==lakei$Lake.ID[1],]#
lakej.day=lakej[lakej$TOD=='Day' & lakej$dateSample==day.dates[length(day.dates)],]#
#
lakej.night=lakej[lakej$TOD=='Night' & lakej$dateSample==night.dates[length(night.dates)],]#
#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML']))#
#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo']))#
#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML']))#
#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo']))#
#
x=c(normal,reverse,noDVM,bottom)#
#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[i],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
fitness=rbind(fitness,y)#
}
fitness<-c()#
for(i in 1:length(lakes)){#
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)#
#
lakej=modelParms[modelParms$lakeID==lakei$Lake.ID[1],]#
lakej.day=lakej[lakej$TOD=='Day' & lakej$dateSample==day.dates[length(day.dates)],]#
#
lakej.night=lakej[lakej$TOD=='Night' & lakej$dateSample==night.dates[length(night.dates)],]#
#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML']))#
#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo']))#
#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML']))#
#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo']))#
#
x=c(normal,reverse,noDVM,bottom)#
#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[i],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
fitness=rbind(fitness,y)#
}
i=2
lakei=dvmZoops[dvmZoops$Lake.ID==lakes[i],] # use only one lake in lakes vector#
lakei=lakei[lakei$Taxa=='daphnia',] # use Daphnia only#
#
day=lakei[lakei$TOD=='Day',]#
day.dates=unique(day$Sample.date) #Get dates for Day and Night samples#
night=lakei[lakei$TOD=='Night',]#
night.dates=unique(night$Sample.date)#
#
lakej=modelParms[modelParms$lakeID==lakei$Lake.ID[1],]#
lakej.day=lakej[lakej$TOD=='Day' & lakej$dateSample==day.dates[length(day.dates)],]#
#
lakej.night=lakej[lakej$TOD=='Night' & lakej$dateSample==night.dates[length(night.dates)],]
lakej.night
night.dates
night.dates[length(night.dates)]
lakej
night=lakei[lakei$TOD=='Night',]
night
modelParms[modelParms$lakeID=='BR',]
lakei=modelParms[modelParms$lakeID==lake,]
lake='BA'
lakei=modelParms[modelParms$lakeID==lake,]
lakei
day.date='07/22/13'
night.date'07/22/13'
lakej.day=lakei[lakei$TOD=='Day' & lakei$dateSample==day.date,]
lakej.day
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]
night.date'07/22/13'
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]
night.date='07/22/13'
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML']))
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo']))
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML']))
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo']))
x=c(normal,reverse,noDVM,bottom)
x=c(normal,reverse,noDVM,bottom)#
#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[i],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
fitness=rbind(fitness,y)
fitness
fitness<-c()
fitness<-c()#
lake='BA'#
lakei=modelParms[modelParms$lakeID==lake,]#
day.date='07/22/13' #find day dates that correspond to plots that actually have data#
night.date='07/22/13' #same for nights#
lakej.day=lakei[lakei$TOD=='Day' & lakei$dateSample==day.date,]#
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML'])) #calculate fitness for normal DVM#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo'])) #calculate fitness for reverse DVM#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML'])) #calculate fitness for noDVM#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo'])) #calculate fitness for daphnia sitting on the bottom#
x=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[i],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
fitness=rbind(fitness,y) #add to fitness
lake=lakes[2]
lake
lakei=modelParms[modelParms$lakeID==lake,]
lakei
day.date='06/04/13' #find day dates that correspond to plots that actually have data#
night.date='06/03/13' #same for nights#
lakej.day=lakei[lakei$TOD=='Day' & lakei$dateSample==day.date,]#
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML'])) #calculate fitness for normal DVM#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo'])) #calculate fitness for reverse DVM#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML'])) #calculate fitness for noDVM#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo'])) #calculate fitness for daphnia sitting on the bottom#
x=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[i],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
fitness=rbind(fitness,y) #add to fitness
fitness
fitness<-c()
lake=lakes[1]
lake
lakei=modelParms[modelParms$lakeID==lake,]
day.date='07/22/13' #find day dates that correspond to plots that actually have data#
night.date='07/22/13' #same for nights#
lakej.day=lakei[lakei$TOD=='Day' & lakei$dateSample==day.date,]#
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML'])) #calculate fitness for normal DVM#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo'])) #calculate fitness for reverse DVM#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML'])) #calculate fitness for noDVM#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo'])) #calculate fitness for daphnia sitting on the bottom#
x=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[1],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)
y
fitness=rbind(fitness,y) #add to fitness
lake=lakes[2]
lakei=modelParms[modelParms$lakeID==lake,]
lakei
day.date='06/04/13' #find day dates that correspond to plots that actually have data#
night.date='06/03/13' #same for nights#
lakej.day=lakei[lakei$TOD=='Day' & lakei$dateSample==day.date,]#
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML'])) #calculate fitness for normal DVM#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo'])) #calculate fitness for reverse DVM#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML'])) #calculate fitness for noDVM#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo'])) #calculate fitness for daphnia sitting on the bottom#
x=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[2],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)
y
fitness=rbind(fitness,y) #add to fitness
lake=lakes[3]
lake
lakei=modelParms[modelParms$lakeID==lake,]
lakei
day.date='07/31/13' #find day dates that correspond to plots that actually have data#
night.date='07/31/13' #same for nights#
lakej.day=lakei[lakei$TOD=='Day' & lakei$dateSample==day.date,]#
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML'])) #calculate fitness for normal DVM#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo'])) #calculate fitness for reverse DVM#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML'])) #calculate fitness for noDVM#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo'])) #calculate fitness for daphnia sitting on the bottom#
x=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[2],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)
y
fitness=rbind(fitness,y) #add to fitness
lake=lakes[4]
lake
lakei=modelParms[modelParms$lakeID==lake,]
lakei
day.date='08/02/13' #find day dates that correspond to plots that actually have data#
night.date='08/01/13' #same for nights#
lakej.day=lakei[lakei$TOD=='Day' & lakei$dateSample==day.date,]#
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML'])) #calculate fitness for normal DVM#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo'])) #calculate fitness for reverse DVM#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML'])) #calculate fitness for noDVM#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo'])) #calculate fitness for daphnia sitting on the bottom#
x=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[2],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)
y
lake=lakes[5]
lake
lakei=modelParms[modelParms$lakeID==lake,]
lakei
day.date='07/26/13' #find day dates that correspond to plots that actually have data#
night.date='07/29/13' #same for nights#
lakej.day=lakei[lakei$TOD=='Day' & lakei$dateSample==day.date,]#
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML'])) #calculate fitness for normal DVM#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo'])) #calculate fitness for reverse DVM#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML'])) #calculate fitness for noDVM#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo'])) #calculate fitness for daphnia sitting on the bottom#
x=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[2],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)
y
fitness<-c()#
i=1#
lake=lakes[i]#
lakei=modelParms[modelParms$lakeID==lake,]#
day.date='07/22/13' #find day dates that correspond to plots that actually have data#
night.date='07/22/13' #same for nights#
lakej.day=lakei[lakei$TOD=='Day' & lakei$dateSample==day.date,]#
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML'])) #calculate fitness for normal DVM#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo'])) #calculate fitness for reverse DVM#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML'])) #calculate fitness for noDVM#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo'])) #calculate fitness for daphnia sitting on the bottom#
x=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[i],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
fitness=rbind(fitness,y) #add to fitness
fitness
i=2#
lake=lakes[i]#
lakei=modelParms[modelParms$lakeID==lake,]
lakei
day.date='06/04/13' #find day dates that correspond to plots that actually have data#
night.date='06/03/13' #same for nights#
lakej.day=lakei[lakei$TOD=='Day' & lakei$dateSample==day.date,]#
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML'])) #calculate fitness for normal DVM#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo'])) #calculate fitness for reverse DVM#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML'])) #calculate fitness for noDVM#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo'])) #calculate fitness for daphnia sitting on the bottom#
x=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[i],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
fitness=rbind(fitness,y) #add to fitness
lake=lakes[i]#
lakei=modelParms[modelParms$lakeID==lake,]
lakei
i=3
lake=lakes[i]
lakei=modelParms[modelParms$lakeID==lake,]
lakei
day.date='07/31/13' #find day dates that correspond to plots that actually have data#
night.date='07/31/13' #same for nights#
lakej.day=lakei[lakei$TOD=='Day' & lakei$dateSample==day.date,]#
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML'])) #calculate fitness for normal DVM#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo'])) #calculate fitness for reverse DVM#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML'])) #calculate fitness for noDVM#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo'])) #calculate fitness for daphnia sitting on the bottom#
x=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[i],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
fitness=rbind(fitness,y) #add to fitness
fitness
lake=lakes[i]#
lakei=modelParms[modelParms$lakeID==lake,]
lakei
i
i=4#
lake=lakes[i]#
lakei=modelParms[modelParms$lakeID==lake,]
lakei
day.date='08/02/13' #find day dates that correspond to plots that actually have data#
night.date='08/01/13' #same for nights#
lakej.day=lakei[lakei$TOD=='Day' & lakei$dateSample==day.date,]#
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML'])) #calculate fitness for normal DVM#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo'])) #calculate fitness for reverse DVM#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML'])) #calculate fitness for noDVM#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo'])) #calculate fitness for daphnia sitting on the bottom#
x=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[i],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
fitness=rbind(fitness,y) #add to fitness
fitness
i=5#
lake=lakes[i]#
lakei=modelParms[modelParms$lakeID==lake,]
lakei
day.date='07/26/13' #find day dates that correspond to plots that actually have data#
night.date='07/29/13' #same for nights#
lakej.day=lakei[lakei$TOD=='Day' & lakei$dateSample==day.date,]#
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML'])) #calculate fitness for normal DVM#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo'])) #calculate fitness for reverse DVM#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML'])) #calculate fitness for noDVM#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo'])) #calculate fitness for daphnia sitting on the bottom#
x=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[i],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)
y
fitness=rbind(fitness,y) #add to fitness
i=6#
lake=lakes[i]#
lakei=modelParms[modelParms$lakeID==lake,]
lakei
day.date='07/24/13' #find day dates that correspond to plots that actually have data#
night.date='07/31/13' #same for nights#
lakej.day=lakei[lakei$TOD=='Day' & lakei$dateSample==day.date,]#
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML'])) #calculate fitness for normal DVM#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo'])) #calculate fitness for reverse DVM#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML'])) #calculate fitness for noDVM#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo'])) #calculate fitness for daphnia sitting on the bottom#
x=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[i],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)
y
fitness=rbind(fitness,y) #add to fitness
i=7#
lake=lakes[i]#
lakei=modelParms[modelParms$lakeID==lake,]
lakei
day.date='07/29/13' #find day dates that correspond to plots that actually have data#
night.date='07/29/13' #same for nights#
lakej.day=lakei[lakei$TOD=='Day' & lakei$dateSample==day.date,]#
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML'])) #calculate fitness for normal DVM#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo'])) #calculate fitness for reverse DVM#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML'])) #calculate fitness for noDVM#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo'])) #calculate fitness for daphnia sitting on the bottom#
x=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[i],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)
y
fitness=rbind(fitness,y) #add to fitness
i=8
lake=lakes[i]#
lakei=modelParms[modelParms$lakeID==lake,]
lakei
i=9
lake=lakes[i]#
lakei=modelParms[modelParms$lakeID==lake,]
lakei
day.date='07/30/13' #find day dates that correspond to plots that actually have data#
night.date='07/30/13' #same for nights#
lakej.day=lakei[lakei$TOD=='Day' & lakei$dateSample==day.date,]#
lakej.night=lakei[lakei$TOD=='Night' & lakei$dateSample==night.date,]#
normal=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.night$depthClass=='PML'])) #calculate fitness for normal DVM#
reverse=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.night$mu.g[lakej.night$depthClass=='Hypo'])) #calculate fitness for reverse DVM#
noDVM=mean(c(lakej.day$mu.g[lakej.day$depthClass=='PML'],lakej.day$mu.g[lakej.day$depthClass=='PML'])) #calculate fitness for noDVM#
bottom=mean(c(lakej.day$mu.g[lakej.day$depthClass=='Hypo'],lakej.night$mu.g[lakej.day$depthClass=='Hypo'])) #calculate fitness for daphnia sitting on the bottom#
x=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==x[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==x[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==x[4]){#
	optimal='bottom'#
}#
y=data.frame(lakeID=lakes[i],date=day.dates[length(day.dates)],normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)
y
fitness=rbind(fitness,y) #add to fitness
i=10#
lake=lakes[i]#
lakei=modelParms[modelParms$lakeID==lake,]
lakei
fitness
boxplot(modelParms$growth~modelParms$depthClass)
boxplot(modelParms$mu~modelParms$depthClass)
boxplot(modelParms$mu[modelParms$TOD=='Day']~modelParms$depthClass[modelParms$TOD=='Day'])
boxplot(modelParms$mu[modelParms$TOD=='Night']~modelParms$depthClass[modelParms$TOD=='Night'])
head(modelParms)
modelParms
boxplot(modelParms$mu[modelParms$TOD=='Day' & modelParms$depthClass=='PML']~modelParms$lakeID[modelParms$TOD=='Day' & modelParms$depthClass=='PML'])
boxplot(modelParms$mu[modelParms$TOD=='Night' & modelParms$depthClass=='PML']~modelParms$lakeID[modelParms$TOD=='Night' & modelParms$depthClass=='PML'])
boxplot(modelParms$mu[modelParms$TOD=='Day' & modelParms$depthClass=='Hypo']~modelParms$lakeID[modelParms$TOD=='Day' & modelParms$depthClass=='Hypo'])
boxplot(modelParms$mu[modelParms$TOD=='Night' & modelParms$depthClass=='Hypo']~modelParms$lakeID[modelParms$TOD=='Night' & modelParms$depthClass=='Hypo'])
boxplot(modelParms$mu[modelParms$TOD=='Night' & modelParms$depthClass=='PML']~modelParms$lakeID[modelParms$TOD=='Night' & modelParms$depthClass=='PML'])
boxplot(modelParms$mu[modelParms$TOD=='Day' & modelParms$depthClass=='Hypo']~modelParms$lakeID[modelParms$TOD=='Day' & modelParms$depthClass=='Hypo'])
boxplot(modelParms$growth[modelParms$TOD=='Day' & modelParms$depthClass=='PML']~modelParms$lakeID[modelParms$TOD=='Day' & modelParms$depthClass=='PML'])
boxplot(modelParms$growth[modelParms$TOD=='Day' & modelParms$depthClass=='Hypo']~modelParms$lakeID[modelParms$TOD=='Day' & modelParms$depthClass=='Hypo'])
This script combines resource quality data into one data frame to be used for growth calculations#
#
#Script adds P data from Ali and Stephen into CN data from the EA#
#script also adds sample information to phosphorus data from isotope log, i.e. lakeID, dateSample, depths, etc.#
#PTK 29 April 2014#
#
#load CN data#
setwd('~/Documents/Notre Dame/CEST Costech EA data/2013 survey/R files')#
cn<-read.csv('EAdataAllData_P-0605_P-0963_FINAL.csv')#
#
#load P data#
setwd('~/Documents/Notre Dame/UNDERC 2013/particulate P data')#
p<-read.csv('ParticulateP_UNDERC2013.csv')#
#
#match sample IDs and add P data to CN data#
pData<-c()#
for(i in 1:nrow(cn)){#
	rowi=match(cn$sample[i],p$sample)#
	pData[i]=p$Pconcentration_ug[rowi]#
}#
cn$P_ug<-pData#
#
#load log data#
setwd('~/Documents/Notre Dame/UNDERC 2013/CP data')#
log<-read.csv('IsotopeLog2013.csv')#
#
#split date.time into seperate date and time vectors#
date<-c()#
time<-c()#
for(i in 1:nrow(log)){#
	dateTime=strsplit(log$Date.time[i],' ')#
	date[i]=dateTime[[1]][1]#
	time[i]=dateTime[[1]][2]#
}#
log$dateSample=date#
log$time=time#
#
#match cn samples with log information and add columns to cn data#
lakeID<-c()#
dateSample<-c()#
depth<-c()#
volFiltered<-c()#
for(i in 1:nrow(cn)){#
	rowi=match(cn$sample[i],log$Isotope.ID)#
	lakeID[i]=log$Lake.ID[rowi]#
	dateSample[i]=log$dateSample[rowi]#
	depth[i]=log$Depth..m.[rowi]#
	volFiltered[i]=log$Volume.Filtered..mL.[rowi]#
}#
cn$lakeID=lakeID#
cn$dateSample=dateSample#
cn$depth=depth#
cn$volFiltered=volFiltered#
#
#Calculate mgP/mgC#
cn$Pmg_Cmg<-(cn$P_ug/1000)/cn$Cmg #mg P per mg C#
#
#Calculate mgC/L for use in EFA calculations#
cn$mgC_L<-cn$Cmg/(as.numeric(cn$volFiltered)/1000)#
#
#add depthClass#
depthClass=rep(NA,nrow(cn)) #make vector of NAs that is the length of cn data#
depthClass[grep('0',cn$depth)]='PML' #fill any depth thta contains a 0 with PML#
depthClass[is.na(depthClass)]='Hypo' #all others make Hypo#
#
cn$depthClass=depthClass #add to cn data#
#
#load EFA data#
setwd('~/Documents/Notre Dame/lipids/final data/2013 survey')#
faData<-read.csv('sestonFAcategorized_8April2014.csv')#
#
#match FA data with the nearest data point for PC and mgC_L#
#remove EL samples from faData#
faData<-faData[faData$lakeID!='EL',]#
faData<-faData[faData$depthClass!='Meta',]#
#remove weird 1000 mL samples - not sure what these are from#
cn<-cn[as.numeric(cn$volFiltered)<1000,]#
cn<-cn[!is.na(cn$mgC_L),]#
#
#for loop that will match nearest mgC_L and P:C data to EFA data - do not have all dates represented, so will need to match to the closest date available to get the best estimate of resource quality possible#
resourceQual<-c()#
for(i in 1:nrow(faData)){#
	samplei=faData[i,]#
	cni=cn[cn$lakeID==samplei$lakeID & cn$depthClass==samplei$depthClass,]#
	cn.noNA=cni[!is.na(cni$Pmg_Cmg),]#
	if(nrow(cni)>=1){#
	mgC_L=cni$mgC_L[which(abs(as.Date(cni$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y')) == min(abs(as.Date(cni$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))))]#
	}#
	if(nrow(cni)<1){#
		mgC_L=NA#
	}#
	if(nrow(cn.noNA)>=1){#
	mgP_mgC=cn.noNA$Pmg_Cmg[which(abs(as.Date(cn.noNA$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y')) == min(abs(as.Date(cn.noNA$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))))]#
	}#
	if(nrow(cn.noNA)<1){#
		mgP_mgC=NA		#
	}#
	samplei$mgC_L=mgC_L#
	samplei$mgP_mgC=mgP_mgC#
	resourceQual=rbind(samplei,resourceQual)#
}#
#
resourceQual$mgEPA_mgC<-(resourceQual$EPA_ugL/1000)/resourceQual$mgC_L#
resourceQual$mgDHA_mgC<-(resourceQual$DHA_ugL/1000)/resourceQual$mgC_L#
resourceQual$C18PUFA_mgC<-(resourceQual$C18PUFA_ugL/1000)/resourceQual$mgC_L#
#
#seperate only the data that I need - cols 4,6,8,22,23,24,25,26#
resourceQual<-resourceQual[,c(4,6,8,22:26)]#
#
#write resource quality data to R files folder#
setwd('~/Documents/Notre Dame/UNDERC 2013/zoop growth model/R files')#
write.csv(resourceQual,'resourceQuality_growth model.csv')#
#
#Add chaoborus density to cn data#
#make unique IDs for cn and chaobDens data that correspond to bring in resource quality data into #
setwd('~/Documents/Notre Dame/UNDERC 2013/zoopData 2013/R files')#
chaobDens<-read.csv('2013chaoborusDensities.csv')#
#
#aggregate resource quality data by lake date and depth#
x=aggregate(resourceQual$mgC_L,by=list(resourceQual$lakeID,resourceQual$dateSample,resourceQual$depthClass),mean,na.rm=T)#
colnames(x)=c('lakeID','dateSample','depthClass','mgC_L')#
y=aggregate(resourceQual$mgP_mgC,by=list(resourceQual$lakeID,resourceQual$dateSample,resourceQual$depthClass),mean,na.rm=T)#
colnames(y)=c('lakeID','dateSample','depthClass','mgP_mgC')#
z=aggregate(resourceQual$mgEPA_mgC,by=list(resourceQual$lakeID,resourceQual$dateSample,resourceQual$depthClass),mean,na.rm=T)#
colnames(z)=c('lakeID','dateSample','depthClass','mgEPA_mgC')#
a=aggregate(resourceQual$mgDHA_mgC,by=list(resourceQual$lakeID,resourceQual$dateSample,resourceQual$depthClass),mean,na.rm=T)#
colnames(a)=c('lakeID','dateSample','depthClass','mgDHA_mgC')#
b=aggregate(resourceQual$C18PUFA_mgC,by=list(resourceQual$lakeID,resourceQual$dateSample,resourceQual$depthClass),mean,na.rm=T)#
colnames(b)=c('lakeID','dateSample','depthClass','C18PUFA_mgC')#
c=aggregate(resourceQual$mgC_L,by=list(resourceQual$lakeID,resourceQual$dateSample,resourceQual$depthClass),mean,na.rm=T)#
colnames(c)=c('lakeID','dateSample','depthClass','mgC_L')#
#
resourceQual=cbind(x,mgC_L=c[,4],mgP_mgC=y[,4],mgEPA_mgC=z[,4],mgDHA_mgC=a[,4],C18PUFA_mgC=b[,4])#
#
#remove CR from chaob data#
chaobDens<-chaobDens[chaobDens$lakeID!='CR',]#
#
#match chaoborus data with resource qual data from the closest date similar to how resource quality data was matched#
modelParms<-c()#
for(i in 1:nrow(chaobDens)){#
	samplei=chaobDens[i,]#
	RQi=resourceQual[resourceQual$lakeID==samplei$lakeID & resourceQual$depthClass==samplei$depthClass,]#
	mgC_L=RQi$mgC_L[which(abs(as.Date(RQi$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y')) == min(abs(as.Date(RQi$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))))]#
	epa=RQi$mgEPA_mgC[which(abs(as.Date(RQi$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y')) == min(abs(as.Date(RQi$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))))]#
	dha=RQi$mgDHA_mgC[which(abs(as.Date(RQi$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y')) == min(abs(as.Date(RQi$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))))]#
	PC=RQi$mgP_mgC[which(abs(as.Date(RQi$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y')) == min(abs(as.Date(RQi$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))))]#
	C18=RQi$C18PUFA_mgC[which(abs(as.Date(RQi$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y')) == min(abs(as.Date(RQi$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))))]#
	samplei$mgC_L=mgC_L#
	samplei$EPA_mgC=epa#
	samplei$DHA_mgC=dha#
	samplei$PC=PC#
	samplei$C18_mgC=C18#
	modelParms=rbind(modelParms,samplei)#
}#
#
#Add date specific DO and temp for each lake and depth#
#need to load profile data from the dB#
setwd('~/Documents/Notre Dame/database') #load the database into R - update as necessary#
library(RSQLite)#
drv=SQLite()#
con=dbConnect(drv,dbname="M2Mdb_021714.db")#
profs<-dbGetQuery(con, 'SELECT profs.lakeID,profs.dateSample,profs.depthClass,profs.depthTop,profs.temp,profs.DOmgL,profs.PAR FROM LIMNO_PROFILES AS profs')#
#use only 2013 data#
setwd('~/Documents/useful R scripts')#
source('addYear.R')#
profs<-addYear(profs)#
profs<-profs[profs$year==2013,]#
#fix dates#
profs$dateSample<-format(as.Date(profs$dateSample,'%Y-%m-%d %H:%M:%S'),'%m/%d/%y')#
#
#Need to get pml and meta depths from chlorophyll data - load from the database#
chl<-dbGetQuery(con,'SELECT chl.lakeID,chl.dateSample,chl.depthClass,chl.depthTop,chl.depthBottom FROM CHLOROPHYLL AS chl')#
#use only 2013 data#
chl<-addYear(chl)#
chl<-chl[chl$year==2013,]#
#fix dateSample#
chl$dateSample=format(as.Date(chl$dateSample,'%Y-%m-%d %H:%M:%S'),'%m/%d/%y')#
#
#find PML and meta depths#
depth<-c()#
for(i in 1:nrow(modelParms)){#
	samplei=modelParms[i,]#
	chlMatch=chl[chl$lakeID==samplei$lakeID,]#
	if(samplei$depthClass=='PML'){#
	pmlDepths=chlMatch[chlMatch$depthClass=='PML',]#
	pmlDepths=pmlDepths$depthBottom[which(abs(as.Date(pmlDepths$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))==min(abs(as.Date(pmlDepths$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))))]#
	depth[i]=mean(c(0,pmlDepths[1]))#
	}#
	else if(samplei$depthClass=='Hypo'){#
	metaDepths=chlMatch[chlMatch$depthClass=='Meta',]#
	metaDepths=metaDepths$depthBottom[which(abs(as.Date(metaDepths$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))==min(abs(as.Date(metaDepths$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))))]#
	depth[i]=metaDepths[1]#
	}#
}#
modelParms$depth=depth#
#
#need to get rid of 0.75m data#
profs=profs[profs$depthTop!=0.75,]#
#
#match depths to DO and temp profiles to get corresponding data#
DOmgL<-c()#
temp<-c()#
PAR<-c()#
for(i in 1:nrow(modelParms)){#
	samplei=modelParms[i,]#
	profMatch=profs[profs$lakeID==samplei$lakeID,]#
	profMatch=profMatch[which(abs(profMatch$depthTop-samplei$depth)==min(abs(profMatch$depthTop-samplei$depth))),]#
	DOmgL[i]=profMatch$DOmgL[which(abs(as.Date(profMatch$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))==min(abs(as.Date(profMatch$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))))]#
	temp[i]=profMatch$temp[which(abs(as.Date(profMatch$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))==min(abs(as.Date(profMatch$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))))]#
	PAR[i]=profMatch$PAR[which(abs(as.Date(profMatch$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))==min(abs(as.Date(profMatch$dateSample,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))))]#
}#
#change PAR for night samples to 0#
PAR[modelParms$TOD=='Night']=0#
PAR=as.numeric(PAR)#
#
#add to model Parms#
modelParms$DOmgL<-DOmgL#
modelParms$temp<-temp#
modelParms$PAR<-PAR#
#
#need to fill in NAs for PAR data - just use average for that depthclass for each lake - make table of lakes and PAR and match data to it#
pmlPAR<-tapply(modelParms$PAR[modelParms$depthClass=='PML'],modelParms$lakeID[modelParms$depthClass=='PML'],mean,na.rm=T)#
hypoPAR<-tapply(modelParms$PAR[modelParms$depthClass=='Hypo'],modelParms$lakeID[modelParms$depthClass=='Hypo'],mean,na.rm=T)#
parData<-data.frame(lakeID=rownames(pmlPAR),PML=pmlPAR,Hypo=hypoPAR)#
for(i in 1:nrow(modelParms)){#
	if(is.na(modelParms$PAR[i])){#
		if(modelParms$depthClass[i]=='PML'){#
			rowi=match(modelParms$lakeID[i],parData$lakeID)#
			modelParms$PAR[i]=parData$PML[rowi]#
		}#
		if(modelParms$depthClass[i]=='Hypo'){#
			rowi=match(modelParms$lakeID[i],parData$lakeID)#
			modelParms$PAR[i]=parData$Hypo[rowi]#
		}#
	}#
	else{#
		i=i+1#
	}#
}#
#
#for DO data that is 0 - replace with mean PML and Meta DO#
#load lakeParms#
setwd('~/Documents/Notre Dame/UNDERC 2013/lakeParameters')#
lakeParms<-read.csv('2014lakeParameters.csv')#
for(i in 1:nrow(modelParms)){#
	if(modelParms$DOmgL[i]==0 & modelParms$depthClass[i]=='PML'){#
		rowi=match(modelParms$lakeID[i],lakeParms$lakeID)#
		modelParms$DOmgL[i]=lakeParms$PML_DO[rowi]#
	}#
}#
#
#Add CPUE data#
#load CPUE data#
setwd('~/Documents/Notre Dame/UNDERC 2013/zoopData 2013/R files')#
fish<-read.csv('fishCPUE.csv')#
#
fish<-fish[c(1,3,6,8,11,13),c(1,2)]#
#
fishAppend<-data.frame(lake=c('TU','CB','RE','RB'),nCPUE=c(fish[6,2],0,0,fish[1,2]))#
#combie estimated fish data#
fish<-rbind(fish,fishAppend)#
#
#Add to modelParms data#
CPUE<-c()#
for(i in 1:nrow(modelParms)){#
	rowi=match(modelParms$lakeID[i],fish$lake)#
	CPUE[i]=fish$nCPUE[rowi]#
}#
modelParms$CPUE=CPUE#
#
#convert CPUE to fish density using density estimate from Mittelbach#
modelParms$fish_m3<-modelParms$CPUE*0.002865#
#Add depth-specific zoop population to calculate predation - add total and taxa specific pop density - do in ind/m3#
#need to load zooplankton data#
setwd('~/Documents/Notre Dame/UNDERC 2013/zoopData 2013/data analyses')#
source('2013DVMcharact_10Feb2014.R')#
#For loop that will take each row of modelParms and will match to specific date and depths to get population - use dvmZoops data frame#
zoops.allDepths<-c() #all zooplankton across all depths#
totZoops<-c() #all zooplankton for that specific depth class#
daphnia<-c()  #daphnia for that specific depth class#
copepods<-c() #copepods for that specific depth class#
holopedium<-c() #holopeium for that specific depth class#
for(i in 1:nrow(modelParms)){#
	samplei<-modelParms[i,]#
	zoops=dvmZoops[dvmZoops$Lake.ID==samplei$lakeID & dvmZoops$TOD==samplei$TOD,]#
	zoops=zoops[which(abs(as.Date(zoops$Sample.date,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y'))==min(abs(as.Date(zoops$Sample.date,'%m/%d/%y')-as.Date(samplei$dateSample,'%m/%d/%y')))),]#
	zoops.allDepths[i]=sum(zoops$Counts,na.rm=T)#
	#use PML depth and pull zoops from 0-PML depth if depth is PML.  For hypo use PML depth -> lake depth#
	rowi=match(samplei$lakeID,lakeParms$lakeID)#
	PMLdepth=ceiling(lakeParms$PMLdepth[rowi])#
	if(samplei$depthClass=='PML'){#
	depthZoops=zoops[zoops$Depth.Top..m.>=0 & zoops$Depth.Top..m.<=PMLdepth,]#
	totZoops[i]=sum(depthZoops$Counts)#
	daphnia[i]=sum(depthZoops$Counts[depthZoops$Taxa=='daphnia'])#
	copepods[i]=sum(depthZoops$Counts[depthZoops$Taxa=='calanoids' | depthZoops$Taxa=='cyclopoids'])#
	holopedium[i]=sum(depthZoops$Counts[depthZoops$Taxa=='holopedium'])#
	}#
	if(samplei$depthClass=='Hypo'){#
		depthZoops=zoops[zoops$Depth.Top..m.>PMLdepth,]#
		totZoops[i]=sum(depthZoops$Counts)#
		daphnia[i]=sum(depthZoops$Counts[depthZoops$Taxa=='daphnia'])#
		copepods[i]=sum(depthZoops$Counts[depthZoops$Taxa=='calanoids' | depthZoops$Taxa=='cyclopoids'])#
		holopedium[i]=sum(depthZoops$Counts[depthZoops$Taxa=='holopedium'])#
	}#
}#
#Convert zooplankton population data into zooplankton/m3 - divide by 15 to get into zoops/L then multiply by 1000 to get in ind/m3#
modelParms$zoops.allDepths<-(zoops.allDepths/15)*1000 #add vectors as columns to model parms data#
modelParms$depthZoops<-(totZoops/15)*1000#
modelParms$Daphnia<-(daphnia/15)*1000#
modelParms$Copepods<-(copepods/15)*1000#
modelParms$Holopedium<-(holopedium/15)*1000
head(modelParms)
modelParms[is.na(modelParms$mgC_L)]
modelParms[is.na(modelParms$mgC_L),]
dbListFields(con, 'POC')
poc<-dbGetQuery(con,'SELECT poc.;akeID,poc.dateSample,poc.depthClass,poc.depthTop,poc.filterVol,poc.sampleAmount,poc.POC,FROM POC AS poc')
poc<-dbGetQuery(con,'SELECT poc.lakeID,poc.dateSample,poc.depthClass,poc.depthTop,poc.filterVol,poc.sampleAmount,poc.POC,FROM POC AS poc')
poc<-dbGetQuery(con,'SELECT * FROM POC')
head(poc)
poc<-addYear(poc)
head(poc)
poc<-poc[poc$year==2013,]
head(poc)
unique(poc$year)
poc<-dbGetQuery(con,'SELECT * FROM POC')
poc<-addYear(poc)
unique(poc$year)
modelParms[is.na(modelParms$EPA_mgC),]
modelParms[is.na(modelParms$PC),]
modelParms[modelParms$lakeID=='WL',]
Zooplankton DVM fitness model - objective is to determine the optimal strategy for a given lake#
#Need to include cost of swimming, and change predation rates in fitness cost of predation, i.e. probability of predation and opporunity costs involved in probability of predation imoacting future reproduction - oxygen survival ratio = model from Koh et al 1997 in Ecological modeling#
#PTK 14 April 2014#
#Calculate u/g for each situation for each lake - use modelParms data frame to calculate u/g for each row of the data frame - will be for each PML Day/Night and Hypo Day/Night, then can compare all situations#
#
library(deSolve)#
#source zooplankton growth submodel - can use this function to determine growth rates in different environments#
setwd('~/Zoop-Fitness-Model')#
source('zoopGrowthSubmodel.R')#
#
#open data frame of model parameters#
setwd('~/Documents/Notre Dame/UNDERC 2013/zoop growth model/R files')#
modelParms<-read.csv('modelParameters_forFitnessModel.csv')#
#
#convert PAR to lx = 1ueinstein m-2 s-1 = 54 lx#
modelParms$lx<-modelParms$PAR*54#
#
#calculate reaction distances for fish - convert to m #
modelParms$reactionDist<-(4.3*log(modelParms$lx,10)*(0.1+log(modelParms$lx,10))^-1)/10#
#change NaNs to 0#
modelParms$reactionDist[is.na(modelParms$reactionDist)]=0#
#
#calculate encounter rates (foraging rate potential) from reaction distance and swimming speeds.  Daphnia swimming speed = 2.26 mm s-1, fish swimming speed = 4.67 cm s-1, chaoborus = nearly 0.  reaction distance of Chaoborus = 2 mm.  Convert to m min-1 -> Daphnia = 0.1356 m min-1, fish = 2.802 m min-1#
vj=2.802 #fish swimming speed#
vi=0.1356 #Daphnia swimming speed#
Pfish<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*modelParms$fish_m3)/modelParms$zoops.allDepths)*720#
#
vj=0.0001 #Chaoborus swimming speed - essentially 0#
Pchaob<-((((pi*0.002^2)/3)*((3*vj^2+vi^2)/vj)*modelParms$ind_m3)/modelParms$Daphnia)*720#
#
modelParms$mu=Pfish+Pchaob#
#
#run growth model on each row of model parameters#
growth<-c()#
for(i in 1:nrow(modelParms)){#
if(!is.na(modelParms$mgC_L[i]) & !is.na(modelParms$PC[i]) & !is.na(modelParms$EPA_mgC[i]) & !is.na(modelParms$DHA_mgC[i])){	#
parms<-c(FQphyt=0.5,PHYT=modelParms$mgC_L[i],FQdet=0.1,DETc=0.1,aC1=0.9,aC2=0.03,lambda=0.6,wPhyt=1,wDet=0,mu=0.035,PCphyt=modelParms$PC[i],fEPA=modelParms$EPA_mgC[i],fDHA=modelParms$DHA_mgC[i],sPC=0.00001,sEPA=0.00001,sDHA=0.00001,tP=0.1,tEPA=0.1,tDHA=0.1,tM=0.05,m=0.05,v=0.5,e=0.05,Pmin=0.009,Popt=0.05,EPAmin=0.0007,EPAopt=0.0082,DHAmin=0.0001,DHAopt=0.0014,X=0.25,hEPA=0.8,hDHA=0.8,r=0.9,p=0.5,thresh=0.05,Jpufa=0.0118)#
#
times=seq(1,500,by=1)#
#
n=c(Pint=0.5,EPAint=0.5,DHAint=0.5)#
#
test<-ode(y=n,times=times,func=timestep,parms=parms)#
#
Pmin=0.009#
Popt=0.05#
EPAmin=0.0007#
EPAopt=0.0082#
DHAmin=0.0001#
DHAopt=0.0014#
r=0.9#
#
#calculate growth rate#
glimP<-(test[41,2]-Pmin)/(Popt-Pmin)#
glimEPA<-(test[41,3]-EPAmin)/(EPAopt-EPAmin)#
glimDHA<-(test[41,4]-DHAmin)/(DHAopt-DHAmin)#
#
r=0.9#
growthi<-r*min(c(glimP,glimEPA,glimDHA))#
growthi<-growthi*exp(-0.015*abs(20-modelParms$temp[i]))#
if(modelParms$DOmgL[i]>=1.1){#
	s=1#
}#
if(modelParms$DOmgL[i]<1.1 & modelParms$DOmgL[i]>=0.2){#
	s=sqrt(1.111*(modelParms$DOmgL-0.2))#
}#
if(modelParms$DOmgL[i]<0.2){#
	s=0#
}#
growth[i]=growthi*s#
if(is.na(modelParms$mgC_L[i]) | is.na(modelParms$PC[i]) | is.na(modelParms$EPA_mgC[i]) | is.na(modelParms$DHA_mgC[i])){#
	growth[i]=NA#
	}#
}#
}#
#
modelParms$growth=growth#
#
#write data to Zoop-Fitness-Model folder#
setwd('~/Zoop-Fitness-Model')#
write.csv(modelParms,'fitnessModel_parameters.csv')
head(modelParms)
