(5/12)*128
(1/3)/(7/640)
(1/3)/(640/7)
(5/12)/(65/64*3)
(1/3)/(5/12)
(1/3)/(7/12)
(5/12)/128
128/(5/12)
128*(5/12)
(5/12)*(1/128)
(1/3)/(65/64*3)
(64*3)/(3*65)
(1/3)/(65/(64*3))
(5/12)/(7/12)
5/7
(5/12)/(5/7)
(5/7)/(5/12)
(5/7)/(640/7)
1-(5/7)/(640/7)
(1/128)*(7/12)
(1/3)+(5/12)
(1/3)/(3/4)
(7/12)*(1/128)
(5/12)+((7/12)*(1/128))
(5/12)/((5/12)+((7/12)*(1/128)))
640/647
260/387
conc=c(0,5,10,25,50,100,200)#
abs=c(0.126,0.182,0.195,0.276,0.452,0.707,1.342)#
plot(conc,abs)
summary(lm(conc~abs))
plot(conc,abs)
summary(lm(abs~conc)) # y =
plot(abs,conc)
xs=c(0.991,0.979,0.260,0.710,0.605,1.173,0.811,0.904,0.797)
for (i in 1:length(xs)){Pconc[i]=-22.443+166.799*xs[i]}
Pconc=c()#
for (i in 1:length(xs)){Pconc[i]=-22.443+166.799*xs[i]}
Pconc
Pconc*0.03
4.28/540
Pconc[3]*10
Pconc2=c()
for(i in 1:length(xs)){Pconc2[i]=0.1350+0.005987*xs[i]}
Pconc2
install.packages("BRugs")
library(deSolve)#
#source zooplankton growth submodel - can use this function to determine growth rates in different environments#
setwd('~/Zoop-Fitness-Model')#
source('zoopGrowthSubmodel.R')#
#
#open data frame of model parameters#
setwd('~/Documents/Notre Dame/UNDERC 2013/zoop growth model/R files')#
modelParms<-read.csv('modelParameters_forFitnessModel.csv')
modelParms
modelParms$fish0<-rep(0,nrow(modelParms))
head(modelParms)
modelParms$fish0.5<-rep(0.5,nrow(modelParms))
modelParms$fish1<-rep(1,nrow(modelParms))
setwd('~/Documents/Notre Dame/UNDERC 2013/zoop growth model/R files')#
modelParms<-read.csv('modelParameters_forFitnessModel.csv')#
#
#add columns of fish density from 0 to 10 fish/m3#
modelParms$fish0<-rep(0,nrow(modelParms))#
modelParms$fish0.1<-rep(0.1,nrow(modelParms))#
modelParms$fish0.25<-rep(0.25,nrow(modelParms))#
modelParms$fish0.5<-rep(0.5,nrow(modelParms))#
modelParms$fish1<-rep(1,nrow(modelParms))#
modelParms$fish5<-rep(5,nrow(modelParms))
head(modelParms)
convert PAR to lx = 1ueinstein m-2 s-1 = 54 lx#
modelParms$lx<-modelParms$PAR*54#
#
#calculate reaction distances for fish - convert to m #
modelParms$reactionDist<-(4.3*log(modelParms$lx,10)*(0.1+log(modelParms$lx,10))^-1)/10#
#change NaNs to 0#
modelParms$reactionDist[is.na(modelParms$reactionDist)]=0#
#
#calculate encounter rates (foraging rate potential) from reaction distance and swimming speeds.  Daphnia swimming speed = 2.26 mm s-1, fish swimming speed = 4.67 cm s-1, chaoborus = nearly 0.  reaction distance of Chaoborus = 2 mm.  Convert to m min-1 -> Daphnia = 0.1356 m min-1, fish = 2.802 m min-1#
vj=2.802 #fish swimming speed#
vi=0.1356 #Daphnia swimming speed
open data frame of model parameters#
setwd('~/Documents/Notre Dame/UNDERC 2013/zoop growth model/R files')#
modelParms<-read.csv('modelParameters_forFitnessModel.csv')#
#
#convert PAR to lx = 1ueinstein m-2 s-1 = 54 lx#
modelParms$lx<-modelParms$PAR*54#
#
#calculate reaction distances for fish - convert to m #
modelParms$reactionDist<-(4.3*log(modelParms$lx,10)*(0.1+log(modelParms$lx,10))^-1)/10#
#change NaNs to 0#
modelParms$reactionDist[is.na(modelParms$reactionDist)]=0#
#
#calculate encounter rates (foraging rate potential) from reaction distance and swimming speeds.  Daphnia swimming speed = 2.26 mm s-1, fish swimming speed = 4.67 cm s-1, chaoborus = nearly 0.  reaction distance of Chaoborus = 2 mm.  Convert to m min-1 -> Daphnia = 0.1356 m min-1, fish = 2.802 m min-1#
vj=2.802 #fish swimming speed#
vi=0.1356 #Daphnia swimming speed
Pfish0<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*0)/modelParms$zoops.allDepths)*720
Pfish0
Pfish0.01<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*0.01)/modelParms$zoops.allDepths)*720
Pfish0.01
Pfish0<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*0)/modelParms$zoops.allDepths)*720#
Pfish0.01<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*0.01)/modelParms$zoops.allDepths)*720#
Pfish0.1<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*0.1)/modelParms$zoops.allDepths)*720#
Pfish0.25<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*0.25)/modelParms$zoops.allDepths)*720#
Pfish0.5<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*0.5)/modelParms$zoops.allDepths)*720#
Pfish1<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*1)/modelParms$zoops.allDepths)*720#
Pfish5<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*5)/modelParms$zoops.allDepths)*720
boxplot(c(Pfish0,Pfish0.01,Pfish0.1,Pfish0.25,Pfish0.5,Pfish1,Pfish5))
boxplot(Pfish0,Pfish0.01,Pfish0.1,Pfish0.25,Pfish0.5,Pfish1,Pfish5)
modelParms$mu0=Pfish0+Pchaob#
modelParms$mu0.01=Pfish0.01+Pchaob#
modelParms$mu0.1=Pfish0.1+Pchaob#
modelParms$mu0.25=Pfish0.25+Pchaob#
modelParms$mu0.5=Pfish0.5+Pchaob#
modelParms$mu1=Pfish1+Pchaob#
modelParms$mu5=Pfish5+Pchaob
model chaoborus predation risk (Encounter rate)#
vj=0.0001 #Chaoborus swimming speed - essentially 0#
Pchaob<-((((pi*0.002^2)/3)*((3*vj^2+vi^2)/vj)*modelParms$ind_m3)/modelParms$Daphnia)*720#
#
#estimate mu using all fish predation rates and chaoborus#
modelParms$mu0=Pfish0+Pchaob#
modelParms$mu0.01=Pfish0.01+Pchaob#
modelParms$mu0.1=Pfish0.1+Pchaob#
modelParms$mu0.25=Pfish0.25+Pchaob#
modelParms$mu0.5=Pfish0.5+Pchaob#
modelParms$mu1=Pfish1+Pchaob#
modelParms$mu5=Pfish5+Pchaob
plot(Pchaob,mu5)
plot(Pchaob,modelParms$mu5)
plot(Pchaob,modelParms$mu5)
abline(a=1)
abline(a=1,b=0)
abline(a=0,b=1)
run growth model on each row of model parameters#
growth<-c()#
for(i in 1:nrow(modelParms)){#
if(!is.na(modelParms$mgC_L[i]) & !is.na(modelParms$PC[i]) & !is.na(modelParms$EPA_mgC[i]) & !is.na(modelParms$DHA_mgC[i])){	#
parms<-c(FQphyt=0.5,PHYT=modelParms$mgC_L[i],FQdet=0.1,DETc=0.1,aC1=0.9,aC2=0.03,lambda=0.6,wPhyt=1,wDet=0,mu=0.035,PCphyt=modelParms$PC[i],fEPA=modelParms$EPA_mgC[i],fDHA=modelParms$DHA_mgC[i],sPC=0.00001,sEPA=0.00001,sDHA=0.00001,tP=0.1,tEPA=0.1,tDHA=0.1,tM=0.05,m=0.05,v=0.5,e=0.05,Pmin=0.009,Popt=0.05,EPAmin=0.0007,EPAopt=0.0082,DHAmin=0.0001,DHAopt=0.0014,X=0.25,hEPA=0.8,hDHA=0.8,r=0.9,p=0.5,thresh=0.05,Jpufa=0.0118)#
#
times=seq(1,500,by=1)#
#
n=c(Pint=0.5,EPAint=0.5,DHAint=0.5)#
#
test<-ode(y=n,times=times,func=timestep,parms=parms)#
#
Pmin=0.009#
Popt=0.05#
EPAmin=0.0007#
EPAopt=0.0082#
DHAmin=0.0001#
DHAopt=0.0014#
r=0.9#
#
#calculate growth rate#
glimP<-(test[41,2]-Pmin)/(Popt-Pmin)#
glimEPA<-(test[41,3]-EPAmin)/(EPAopt-EPAmin)#
glimDHA<-(test[41,4]-DHAmin)/(DHAopt-DHAmin)#
#
r=0.9#
growthi<-r*min(c(glimP,glimEPA,glimDHA))#
growthi<-growthi*exp(-0.015*abs(20-modelParms$temp[i]))#
if(modelParms$DOmgL[i]>=1.1){#
	s=1#
}#
if(modelParms$DOmgL[i]<1.1 & modelParms$DOmgL[i]>=0.2){#
	s=sqrt(1.111*(modelParms$DOmgL-0.2))#
}#
if(modelParms$DOmgL[i]<0.2){#
	s=0#
}#
growth[i]=growthi*s#
if(is.na(modelParms$mgC_L[i]) | is.na(modelParms$PC[i]) | is.na(modelParms$EPA_mgC[i]) | is.na(modelParms$DHA_mgC[i])){#
	growth[i]=NA#
	}#
}#
}#
#
modelParms$growth=growth
head(modelParms)
setwd('~/Zoop-Fitness-Model')#
source('zoopGrowthSubmodel.R')#
#
#open data frame of model parameters#
setwd('~/Documents/Notre Dame/UNDERC 2013/zoop growth model/R files')#
modelParms<-read.csv('modelParameters_forFitnessModel.csv')#
#
#convert PAR to lx = 1ueinstein m-2 s-1 = 54 lx#
modelParms$lx<-modelParms$PAR*54#
#
#calculate reaction distances for fish - convert to m #
modelParms$reactionDist<-(4.3*log(modelParms$lx,10)*(0.1+log(modelParms$lx,10))^-1)/10#
#change NaNs to 0#
modelParms$reactionDist[is.na(modelParms$reactionDist)]=0#
#
#calculate encounter rates (foraging rate potential) from reaction distance and swimming speeds.  Daphnia swimming speed = 2.26 mm s-1, fish swimming speed = 4.67 cm s-1, chaoborus = nearly 0.  reaction distance of Chaoborus = 2 mm.  Convert to m min-1 -> Daphnia = 0.1356 m min-1, fish = 2.802 m min-1#
vj=2.802 #fish swimming speed#
vi=0.1356 #Daphnia swimming speed#
#
#make Pfish column for varying fish density (0-5 fish/m3)#
PfishEst<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*modelParms$fish_m3)/modelParms$zoops.allDepths)*720#
Pfish0<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*0)/modelParms$zoops.allDepths)*720#
Pfish0.01<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*0.01)/modelParms$zoops.allDepths)*720#
Pfish0.1<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*0.1)/modelParms$zoops.allDepths)*720#
Pfish0.25<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*0.25)/modelParms$zoops.allDepths)*720#
Pfish0.5<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*0.5)/modelParms$zoops.allDepths)*720#
Pfish1<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*1)/modelParms$zoops.allDepths)*720#
Pfish5<-((((pi*modelParms$reactionDist^2)/3)*((3*vj^2+vi^2)/vj)*5)/modelParms$zoops.allDepths)*720#
#
#model chaoborus predation risk (Encounter rate)#
vj=0.0001 #Chaoborus swimming speed - essentially 0#
Pchaob<-((((pi*0.002^2)/3)*((3*vj^2+vi^2)/vj)*modelParms$ind_m3)/modelParms$Daphnia)*720#
#
#estimate mu using all fish predation rates and chaoborus#
modelParms$muEst=PfishEst+Pchaob#
modelParms$mu0=Pfish0+Pchaob#
modelParms$mu0.01=Pfish0.01+Pchaob#
modelParms$mu0.1=Pfish0.1+Pchaob#
modelParms$mu0.25=Pfish0.25+Pchaob#
modelParms$mu0.5=Pfish0.5+Pchaob#
modelParms$mu1=Pfish1+Pchaob#
modelParms$mu5=Pfish5+Pchaob
head(modelParms)
run growth model on each row of model parameters#
growth<-c()#
for(i in 1:nrow(modelParms)){#
if(!is.na(modelParms$mgC_L[i]) & !is.na(modelParms$PC[i]) & !is.na(modelParms$EPA_mgC[i]) & !is.na(modelParms$DHA_mgC[i])){	#
parms<-c(FQphyt=0.5,PHYT=modelParms$mgC_L[i],FQdet=0.1,DETc=0.1,aC1=0.9,aC2=0.03,lambda=0.6,wPhyt=1,wDet=0,mu=0.035,PCphyt=modelParms$PC[i],fEPA=modelParms$EPA_mgC[i],fDHA=modelParms$DHA_mgC[i],sPC=0.00001,sEPA=0.00001,sDHA=0.00001,tP=0.1,tEPA=0.1,tDHA=0.1,tM=0.05,m=0.05,v=0.5,e=0.05,Pmin=0.009,Popt=0.05,EPAmin=0.0007,EPAopt=0.0082,DHAmin=0.0001,DHAopt=0.0014,X=0.25,hEPA=0.8,hDHA=0.8,r=0.9,p=0.5,thresh=0.05,Jpufa=0.0118)#
#
times=seq(1,500,by=1)#
#
n=c(Pint=0.5,EPAint=0.5,DHAint=0.5)#
#
test<-ode(y=n,times=times,func=timestep,parms=parms)#
#
Pmin=0.009#
Popt=0.05#
EPAmin=0.0007#
EPAopt=0.0082#
DHAmin=0.0001#
DHAopt=0.0014#
r=0.9#
#
#calculate growth rate#
glimP<-(test[41,2]-Pmin)/(Popt-Pmin)#
glimEPA<-(test[41,3]-EPAmin)/(EPAopt-EPAmin)#
glimDHA<-(test[41,4]-DHAmin)/(DHAopt-DHAmin)#
#
r=0.9#
growthi<-r*min(c(glimP,glimEPA,glimDHA))#
growthi<-growthi*exp(-0.015*abs(20-modelParms$temp[i]))#
if(modelParms$DOmgL[i]>=1.1){#
	s=1#
}#
if(modelParms$DOmgL[i]<1.1 & modelParms$DOmgL[i]>=0.2){#
	s=sqrt(1.111*(modelParms$DOmgL-0.2))#
}#
if(modelParms$DOmgL[i]<0.2){#
	s=0#
}#
growth[i]=growthi*s#
if(is.na(modelParms$mgC_L[i]) | is.na(modelParms$PC[i]) | is.na(modelParms$EPA_mgC[i]) | is.na(modelParms$DHA_mgC[i])){#
	growth[i]=NA#
	}#
}#
}#
#
modelParms$growth=growth#
#
#write data to Zoop-Fitness-Model folder#
setwd('~/Zoop-Fitness-Model')#
write.csv(modelParms,'fitnessModel_parameters_sensAnalysis.csv')
setwd('~/Zoop-Fitness-Model')#
modelParms<-read.csv('fitnessModel_parameters_sensAnalysis.csv')
head(modelParms)
modelParms<-modelParms[,-c(1:3)]
modelParms$mu.gEst<-exp(modelParms$muEst)/exp(modelParms$growth)#
modelParms$mu.g0<-exp(modelParms$mu0)/exp(modelParms$growth)#
modelParms$mu.g0.01<-exp(modelParms$mu0.01)/exp(modelParms$growth)#
modelParms$mu.g0.1<-exp(modelParms$mu0.1)/exp(modelParms$growth)#
modelParms$mu.g0.25<-exp(modelParms$mu0.25)/exp(modelParms$growth)#
modelParms$mu.g0.5<-exp(modelParms$mu0.5)/exp(modelParms$growth)#
modelParms$mu.g1<-exp(modelParms$mu1)/exp(modelParms$growth)#
modelParms$mu.g5<-exp(modelParms$mu5)/exp(modelParms$growth)
Go through each lake and calculate fitness comparisons for each situation for the last date#
#convert dates into matching format#
modelParms$dateSample<-format(as.Date(modelParms$dateSample,'%m/%d/%y'),'%m/%d/%y')#
#
#remove NAs from data#
modelParms<-modelParms[!is.na(modelParms$EPA_mgC),]#
#remove bad dates#
modelParms<-modelParms[modelParms$dateSample!='05/22/12',]#
#
#make vector of lakes#
lakes<-unique(modelParms$lakeID)
i=1
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()
lakei
night.dates
j=1
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(j,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data$mu.g[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day'],tot.data$mu.g[tot.data$depthClass=='PML' & tot.data$TOD=='Night']),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data$mu.g[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night'],tot.data$mu.g[tot.data$depthClass=='PML' & tot.data$TOD=='Day']),na.rm=T)#
noDVM=mean(c(tot.data$mu.g[tot.data$depthClass=='PML' & tot.data$TOD=='Day'],tot.data$mu.g[tot.data$depthClass=='PML' & tot.data$TOD=='Night']),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data$mu.g[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day'],tot.data$mu.g[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night']),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
}#
y=data.frame(lakeID=lakes[i],date=night.dates[j],dayDifference=day.diff,normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal,pml.chaob.day=tot.data$ind_m3[tot.data$depthClass=='PML' & tot.data$TOD=='Day'],fishDens=tot.data$fish_m3[1],rxDist.pml.day=tot.data$reactionDist[tot.data$depthClass=='PML' & tot.data$TOD=='Day'],EPA.diff=tot.data$EPA_mgC[tot.data$depthClass=='PML'][1]-tot.data$EPA_mgC[tot.data$depthClass=='Hypo'][1],DHA.diff=tot.data$DHA_mgC[tot.data$depthClass=='PML'][1]-tot.data$DHA_mgC[tot.data$depthClass=='Hypo'][1],P.diff=tot.data$PC[tot.data$depthClass=='PML'][1]-tot.data$PC[tot.data$depthClass=='Hypo'][1],diff.C=tot.data$mgC_L[tot.data$depthClass=='PML'][1]-tot.data$mgC_L[tot.data$depthClass=='Hypo'][1],growth.diff=tot.data$growth[tot.data$depthClass=='PML'][1]-tot.data$growth[tot.data$depthClass=='Hypo'][1])#
x=rbind(x,y)
normal
normal=mean(c(tot.data$mu.g[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day'],tot.data$mu.g[tot.data$depthClass=='PML' & tot.data$TOD=='Night']),na.rm=T) #calculate fitness for normal DVM
i=1
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()
j=1
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(j,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))
tot.data
night.data
lakei.day
lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]
lakei
j
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))
tot.data
g=26
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T)
normal
g
colnames(tot.data[g])
g=35
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
}#
y=data.frame(lakeID=lakes[i],date=night.dates[j],colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal
y
y
y=data.frame(lakeID=lakes[i],date=night.dates[j],colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)
y
fitnessTest<-c()#
#
for(i in 1:length(lakes)){#
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()#
for(j in 1:length(night.dates)){#
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
}#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
fitnessTest=rbind(fitnessTest,x) #add to fitness#
}
fitnessTest<-c()#
#
for(i in 1:length(lakes)){#
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()#
for(j in 1:length(night.dates)){#
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
}#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
x=rbind(x,sens)#
}#
fitnessTest=rbind(fitnessTest,x) #add to fitness#
}
}
fitnessTest<-c()#
#
for(i in 1:length(lakes)){#
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()#
for(j in 1:length(night.dates)){#
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
}#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
x=rbind(x,sens)#
}#
fitnessTest=rbind(fitnessTest,x) #add to fitness#
}
i=1
j=1
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()
tot.data
g=35
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
}
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
}
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)
sens
x
i=1
j=1
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()#
for(j in 1:length(night.dates)){#
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}
}
i=1
j=1
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
}
for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
x=rbind(x,sens)#
}
x
fitnessTest<-c()#
#
for(i in 1:length(lakes)){#
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()#
for(j in 1:length(night.dates)){#
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
}#
x=rbind(x,sens)#
}#
fitnessTest=rbind(fitnessTest,x) #add to fitness#
}
i=1
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()#
for(j in 1:length(night.dates)){#
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
}#
x=rbind(x,sens)#
}
x
i=2
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()#
for(j in 1:length(night.dates)){#
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
}#
x=rbind(x,sens)#
}
x
i=3
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()#
for(j in 1:length(night.dates)){#
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
}#
x=rbind(x,sens)#
}
i=4
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()#
for(j in 1:length(night.dates)){#
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
}#
x=rbind(x,sens)#
}
x
i=5
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()#
for(j in 1:length(night.dates)){#
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
}#
x=rbind(x,sens)#
}
i=6
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()#
for(j in 1:length(night.dates)){#
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
}#
x=rbind(x,sens)#
}
i=7
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()#
for(j in 1:length(night.dates)){#
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
}#
x=rbind(x,sens)#
}
i=8
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()#
for(j in 1:length(night.dates)){#
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
}#
x=rbind(x,sens)#
}
i=9
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()#
for(j in 1:length(night.dates)){#
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
}#
x=rbind(x,sens)#
}
i=10
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()#
for(j in 1:length(night.dates)){#
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
}#
x=rbind(x,sens)#
}
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]
lakei
j=1
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
}#
x=rbind(x,sens)
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM
normal
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)
reverse
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM
noDVM
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom
bottom
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}
min(c(normal,reverse,noDVM,bottom,na.rm=T))==z[1]
i=1
j=1
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(x,y)#
}#
}#
x=rbind(x,sens)
x
sens
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()#
for(j in 1:length(night.dates)){#
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(sens,y)#
}#
}#
x=rbind(x,sens)#
}
x
fitnessTest<-c()#
#
for(i in 1:9){#
lakei=modelParms[modelParms$lakeID==lakes[i],]#
night.dates=unique(lakei$dateSample[lakei$TOD=='Night']) #same for nights#
#use day data from closest date#
night.dates=night.dates[order(night.dates)]#
x=c()#
for(j in 1:length(night.dates)){#
night.data=lakei[lakei$TOD=='Night' & lakei$dateSample==night.dates[j],]#
lakei.day<-lakei[lakei$TOD=='Day',]#
day.data<-lakei.day[which(abs(as.Date(lakei$dateSample[lakei$TOD=='Day' ],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))==min(abs(as.Date(lakei$dateSample[lakei$TOD=='Day'],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y')))),]#
tot.data<-rbind(night.data,day.data)#
day.diff<-abs(as.Date(day.data$dateSample[1],'%m/%d/%y')-as.Date(night.dates[j],'%m/%d/%y'))#
if(nrow(tot.data)<4){#
	j=j+1#
}#
sens<-c()#
	for(g in 35:42){#
if(nrow(tot.data)==4){#
normal=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for normal DVM#
reverse=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g]),na.rm=T)#
noDVM=mean(c(tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='PML' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for noDVM#
bottom=mean(c(tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Day',g],tot.data[tot.data$depthClass=='Hypo' & tot.data$TOD=='Night',g]),na.rm=T) #calculate fitness for daphnia sitting on the bottom#
z=c(normal,reverse,noDVM,bottom) #make into vector#
if(min(c(normal,reverse,noDVM,bottom))==z[1]){#
	optimal='normal'#
} #find minimum --> optimal strategy#
if(min(c(normal,reverse,noDVM,bottom))==z[2]){#
	optimal='reverse'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[3]){#
	optimal='noDVM'#
}#
if(min(c(normal,reverse,noDVM,bottom))==z[4]){#
	optimal='bottom'#
}#
#
y=data.frame(lakeID=lakes[i],date=night.dates[j],mu.g=colnames(tot.data[g]),normal=normal,reverse=reverse,noDVM=noDVM,bottom=bottom,optimal=optimal)#
sens=rbind(sens,y)#
}#
}#
x=rbind(x,sens)#
}#
fitnessTest=rbind(fitnessTest,x) #add to fitness#
}
fitnessTest
1/27.5
curve(2.65*x*exp(-0.0363636*x),from=0,to=40)
10/(27.5-24)
b1<--0.325 #weight dependence exponent for maximum consumption
b1
Tm=37 #maximum temperature (from Rice et al 1983)#
Topt=27.5 #optimal temperature (from Rice et al 1983)#
Tamb=19 #user input <-------------#
V=(Tm-Tamb)/(Tm-Topt)
V
Q=2.65 #slope value from Rice et al. 1983#
W=log(Q)*(Tm-Topt)#
Y=log(Q)*(Tm-Topt+2)#
X=(W^2*(1+(1+40/Y)^0.5))^2/400
X
rc<-(V^X)*exp(X*(1-V))
rc
V
X
log(Q)
(Tm-Topt)
W
Y
X<-((W^2*(1+(1+40/Y)^0.5))^2)/400
X
W^2
(1+(1+40/Y)^0.5)
X<-((W^2*(1+(1+40/Y)^0.5)^2))/400
X
Q<-2.65 #slope value from Rice et al. 1983#
W<-log(Q)*(Tm-Topt)#
Y<-log(Q)*(Tm-Topt+2)#
X<-((W^2*(1+(1+40/Y)^0.5)^2))/400#
#
rc<-(V^X)*exp(X*(1-V))
rc
Cmax<-a1*B*b1
a1<-0.33 #intercept for maximum consumption (g g-1 day-1)#
b1<--0.325 #weight dependence exponent for maximum consumption#
B<-400 #biomass in grams - user input <--------------#
#
Cmax<-a1*B*b1
Cmax
a1*B
Cmax<-a1*B^b1
Cmax
C<-Cmax*rc*P
P<-0.7 #proportionality constant from 0 to 1, used to adjust the ration when fitting an observed growth curve - user input <---------------#
#
C<-Cmax*rc*P
C
a2<-0.348 #intercept for respiration (mg O2 g-1 hr-1)#
m<-0.0313 #coefficient for temperature dependence of respiration (deg. C-1)#
g<-0.0196 #coefficient for swimming speed dependence of respiration (s cm-1)#
S<-5 #swimming speed (cm s-1)#
#
Rsa<-a2*B^b2*exp(m*Tamb)*exp(g*S)
a2<-0.348 #intercept for respiration (mg O2 g-1 hr-1)#
b2<--0.355 #weight dependence exponent for respiration#
m<-0.0313 #coefficient for temperature dependence of respiration (deg. C-1)#
g<-0.0196 #coefficient for swimming speed dependence of respiration (s cm-1)#
S<-5 #swimming speed (cm s-1)#
#
Rsa<-a2*B^b2*exp(m*Tamb)*exp(g*S)
Rsa
C
Rsa<-a2*B^b2*(m*exp(Tamb))*exp(g*S)
Rsa
e
ln(1)
log(1)
log(0)
log(1)
exp(1)
Rsa<-a2*B^b2*(exp(1)*m^Tamb)*exp(g*S) #respiration - standard metabolism and activity
Rsa
Rsa<-a2*B^b2*(exp(1)*m^Tamb)*(exp(1)*g*S) #respiration - standard metabolism and activity
Rsa
(exp(1)*m^Tamb)
m^Tamb
(exp(1)*m)^Tamb
Tamb
exp(1)*m)
(exp(1)*m)
a2<-0.348 #intercept for respiration (mg O2 g-1 hr-1)#
b2<--0.355 #weight dependence exponent for repsiration#
Rmax<-a2*B^b2
Rmax
Topt<-32#
Tm<-34#
Q<-2.1#
W<-log(Q)*(Tm-Topt)#
Y<-log(Q)*(Tm-Topt+2)#
X<-((W^2*(1+(1+40/Y)^0.5)^2))/400#
#
rc<-(V^X)*exp(X*(1-V))
rR<-(V^X)*exp(X*(1-V))
rR
a2<-0.348 #intercept for respiration (mg O2 g-1 hr-1)#
b2<--0.355 #weight dependence exponent for repsiration#
Rmax<-a2*B^b2#
#
A=1 #activity coefficient (from Kitchell 1977)#
#
Topt<-32#
Tm<-34#
Q<-2.1#
W<-log(Q)*(Tm-Topt)#
Y<-log(Q)*(Tm-Topt+2)#
X<-((W^2*(1+(1+40/Y)^0.5)^2))/400#
#
rR<-(V^X)*exp(X*(1-V)) #a temperature dependent proportional adjustment of repsiration#
#
S<-0.142 #proportion of consumed energy utilixed in apparent SDA#
#
R<-Rmax*A*rR+(S*C)
R
Bioenergetics model for largemouth bass - adapted from Kitchell and Stewart 1977 and Rice et al. 1983#
#Patrick Kelly 15 July 2014#
#
#overarching model is dBbdt = C - (Rsa + Rsda +F +U) in kJ g-1 d-1 - conversion rate -> 1g = 4.184 kJ to convert to biomass rate#
#
#start by modeling consumption#
#C = Cmax * rc * P#
#Cmax = a1*B*b1#
#
a1<-0.33 #intercept for maximum consumption (g g-1 day-1)#
b1<--0.325 #weight dependence exponent for maximum consumption#
B<-400 #biomass in grams - user input <--------------#
#
Cmax<-a1*B^b1#
#
Tm<-37 #maximum temperature (from Rice et al 1983)#
Topt<-27.5 #optimal temperature (from Rice et al 1983)#
Tamb<-19 #user input <-------------#
V<-(Tm-Tamb)/(Tm-Topt)#
#
Q<-2.65 #slope value from Rice et al. 1983#
W<-log(Q)*(Tm-Topt)#
Y<-log(Q)*(Tm-Topt+2)#
X<-((W^2*(1+(1+40/Y)^0.5)^2))/400#
#
rc<-(V^X)*exp(X*(1-V)) #temperature dependent proportional adjustment (0 to 1) of consumption rate - from Kitchell and Stewart 1977#
#
P<-0.7 #proportionality constant from 0 to 1, used to adjust the ration when fitting an observed growth curve - user input <---------------#
#
C<-Cmax*rc*P #consumption rate #
#
#Respiration#
#R = Rmax * A * rR + SC#
#
a2<-0.348 #intercept for respiration (mg O2 g-1 hr-1)#
b2<--0.355 #weight dependence exponent for repsiration#
Rmax<-a2*B^b2#
#
A=1 #activity coefficient (from Kitchell 1977)#
#
Topt<-32#
Tm<-34#
Q<-2.1#
W<-log(Q)*(Tm-Topt)#
Y<-log(Q)*(Tm-Topt+2)#
X<-((W^2*(1+(1+40/Y)^0.5)^2))/400#
#
rR<-(V^X)*exp(X*(1-V)) #a temperature dependent proportional adjustment of repsiration#
#
S<-0.142 #proportion of consumed energy utilixed in apparent SDA#
#
R<-Rmax*A*rR+(S*C) #respiration/metabolism#
#
#Egestion#
f<-0.104 #proportion of consumed energy lost through egestion #
F<-f*C#
#
#Excretion#
u<-0.079 #proportion of energy lost through excretion#
U<-u*C#
#
dB.Bdt<-C-(R+F+U)
dB.Bdt
Cmax
Bioenergetics model for largemouth bass - adapted from Kitchell and Stewart 1977 and Rice et al. 1983#
#Patrick Kelly 15 July 2014#
#
#overarching model is dBbdt = C - (Rsa + Rsda +F +U) in kJ g-1 d-1 - conversion rate -> 1g = 4.184 kJ to convert to biomass rate#
#
#start by modeling consumption#
#C = Cmax * rc * P#
#Cmax = a1*B*b1#
#
a1<-0.33 #intercept for maximum consumption (g g-1 day-1)#
b1<--0.325 #weight dependence exponent for maximum consumption#
B<-400 #biomass in grams - user input <--------------#
#
Cmax<-a1*B^b1#
#
Tm<-37 #maximum temperature (from Rice et al 1983)#
Topt<-27.5 #optimal temperature (from Rice et al 1983)#
Tamb<-19 #user input <-------------#
V<-(Tm-Tamb)/(Tm-Topt)#
#
Q<-2.65 #slope value from Rice et al. 1983#
W<-log(Q)*(Tm-Topt)#
Y<-log(Q)*(Tm-Topt+2)#
X<-((W^2*(1+(1+40/Y)^0.5)^2))/400#
#
rc<-(V^X)*exp(X*(1-V)) #temperature dependent proportional adjustment (0 to 1) of consumption rate - from Kitchell and Stewart 1977#
#
P<-0.7 #proportionality constant from 0 to 1, used to adjust the ration when fitting an observed growth curve - user input <---------------#
#
C<-Cmax*rc*P #consumption rate #
#
#Respiration - equation from Rice et al 1983 doesn't make sense, so used the equation from #
#R = Rmax * A * rR + SC#
#
a2<-0.348 #intercept for respiration (mg O2 g-1 hr-1)#
b2<--0.355 #weight dependence exponent for repsiration#
Rmax<-a2*B^b2#
#
A=1 #activity coefficient (from Kitchell 1977)#
#
Topt<-28#
Tm<-34#
Q<-2.1#
W<-log(Q)*(Tm-Topt)#
Y<-log(Q)*(Tm-Topt+2)#
X<-((W^2*(1+(1+40/Y)^0.5)^2))/400#
#
rR<-(V^X)*exp(X*(1-V)) #a temperature dependent proportional adjustment of repsiration#
#
S<-0.142 #proportion of consumed energy utilixed in apparent SDA#
#
R<-Rmax*A*rR+(S*C) #respiration/metabolism#
#
#Egestion#
f<-0.104 #proportion of consumed energy lost through egestion #
F<-f*C#
#
#Excretion#
u<-0.079 #proportion of energy lost through excretion#
U<-u*C#
#
dB.Bdt<-C-(R+F+U) #specific growth rate equation
dB.Bdt
